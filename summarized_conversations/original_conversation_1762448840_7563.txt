{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="HEX-CyberSphere/cpp_engine/compressor.cpp">\n/*\nHEX-CyberSphere C++ Compression Module\nHigh-speed data compression and decompression\n*/\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <zlib.h>\n#include <iomanip>\n#include <sstream>\n\nclass Compressor {\npublic:\n    // Compress data using zlib\n    std::string compress(const std::string& data) {\n        z_stream zs;\n        memset(&zs, 0, sizeof(zs));\n\n        if (deflateInit(&zs, Z_BEST_COMPRESSION) != Z_OK) {\n            throw std::runtime_error("deflateInit failed");\n        }\n\n        zs.next_in = reinterpret_cast<Bytef*>(const_cast<char*>(data.data()));\n        zs.avail_in = data.size();\n\n        int ret;\n        char outbuffer[32768];\n        std::string outstring;\n\n        do {\n            zs.next_out = reinterpret_cast<Bytef*>(outbuffer);\n            zs.avail_out = sizeof(outbuffer);\n\n            ret = deflate(&zs, Z_SYNC_FLUSH);\n\n            if (outstring.size() < zs.total_out) {\n                outstring.append(outbuffer, zs.total_out - outstring.size());\n            }\n        } while (ret == Z_OK);\n\n        deflateEnd(&zs);\n\n        if (ret != Z_STREAM_END) {\n            throw std::runtime_error("Exception during zlib compression");\n        }\n\n        // Convert to hex string for easy transport\n        std::stringstream ss;\n        for (unsigned char c : outstring) {\n            ss << std::hex << std::setw(2) << std::setfill(\'0\') << static_cast<int>(c);\n        }\n        return ss.str();\n    }\n\n    // Decompress data using zlib\n    std::string decompress(const std::string& hexCompressed) {\n        // Convert hex string to bytes\n        std::vector<unsigned char> compressed(hexCompressed.length() / 2);\n        for (size_t i = 0; i < hexCompressed.length(); i += 2) {\n            std::string byteString = hexCompressed.substr(i, 2);\n            compressed[i / 2] = static_cast<unsigned char>(std::stoi(byteString, nullptr, 16));\n        }\n\n        z_stream zs;\n        memset(&zs, 0, sizeof(zs));\n\n        if (inflateInit(&zs) != Z_OK) {\n            throw std::runtime_error("inflateInit failed");\n        }\n\n        zs.next_in = reinterpret_cast<Bytef*>(compressed.data());\n        zs.avail_in = compressed.size();\n\n        int ret;\n        char outbuffer[32768];\n        std::string outstring;\n\n        do {\n            zs.next_out = reinterpret_cast<Bytef*>(outbuffer);\n            zs.avail_out = sizeof(outbuffer);\n\n            ret = inflate(&zs, Z_SYNC_FLUSH);\n\n            if (outstring.size() < zs.total_out) {\n                outstring.append(outbuffer, zs.total_out - outstring.size());\n            }\n        } while (ret == Z_OK);\n\n        inflateEnd(&zs);\n\n        if (ret != Z_STREAM_END) {\n            throw std::runtime_error("Exception during zlib decompression");\n        }\n\n        return outstring;\n    }\n\n    // Calculate compression ratio\n    double calculateRatio(const std::string& original, const std::string& compressed) {\n        if (original.empty()) return 0.0;\n        return static_cast<double>(compressed.length()) / static_cast<double>(original.length());\n    }\n};\n\n// Main function for testing\nint main() {\n    std::cout << "╔════════════════════════════════════════════════╗" << std::endl;\n    std::cout << "║              ⚡ H E X – C Y B E R S P H E R E ⚡              ║" << std::endl;\n    std::cout << "╚════════════════════════════════════════════════╝" << std::endl;\n    std::cout << "     C++ Compression Engine" << std::endl;\n    std::cout << "  High-speed data compression" << std::endl;\n    std::cout << std::endl;\n\n    Compressor compressor;\n\n    // Test compression\n    std::string original = "This is a test string for compression. ";\n    // Repeat the string to make it larger\n    for (int i = 0; i < 10; i++) {\n        original += original;\n    }\n\n    std::cout << "Original size: " << original.length() << " bytes" << std::endl;\n\n    try {\n        std::string compressed = compressor.compress(original);\n        std::cout << "Compressed size: " << compressed.length() / 2 << " bytes" << std::endl;\n\n        double ratio = compressor.calculateRatio(original, compressed);\n        std::cout << "Compression ratio: " << std::fixed << std::setprecision(2) << ratio << std::endl;\n\n        std::string decompressed = compressor.decompress(compressed);\n        std::cout << "Decompression successful: " << (decompressed == original ? "YES" : "NO") << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << "Error: " << e.what() << std::endl;\n    }\n\n    return 0;\n}\n</create-file>\n</function_calls>'}