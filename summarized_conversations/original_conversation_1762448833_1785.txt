{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="HEX-CyberSphere/node_events/index.js">\n/**\n * HEX-CyberSphere Node.js Event System\n * Webhook system, event handler, and real-time communication\n */\n\nconst express = require(\'express\');\nconst http = require(\'http\');\nconst socketIo = require(\'socket.io\');\nconst axios = require(\'axios\');\nconst puppeteer = require(\'puppeteer\');\n\n// Create Express app\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server, {\n  cors: {\n    origin: "*",\n    methods: ["GET", "POST"]\n  }\n});\n\n// Middleware\napp.use(express.json());\napp.use(express.static(\'public\'));\n\n// Store active connections\nconst connections = new Map();\n\n// Health check endpoint\napp.get(\'/health\', (req, res) => {\n  res.json({\n    status: \'healthy\',\n    service: \'node_events\',\n    timestamp: new Date().toISOString()\n  });\n});\n\n// Main endpoint\napp.get(\'/\', (req, res) => {\n  res.json({\n    system: \'HEX-CyberSphere Node.js Event System\',\n    version: \'1.0.0\',\n    description: \'Webhook system, event handler, and real-time communication\'\n  });\n});\n\n// Web automation endpoint\napp.post(\'/automate\', async (req, res) => {\n  try {\n    const { url, actions, options } = req.body;\n    \n    console.log(`Starting web automation for ${url}`);\n    \n    // Emit event to all connected clients\n    io.emit(\'automation_start\', {\n      url,\n      timestamp: new Date().toISOString(),\n      status: \'starting\'\n    });\n    \n    // Perform web automation using Puppeteer\n    const result = await performWebAutomation(url, actions, options);\n    \n    // Emit completion event\n    io.emit(\'automation_complete\', {\n      url,\n      result,\n      timestamp: new Date().toISOString(),\n      status: \'completed\'\n    });\n    \n    res.json({\n      status: \'success\',\n      result,\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    console.error(\'Web automation error:\', error);\n    \n    // Emit error event\n    io.emit(\'automation_error\', {\n      error: error.message,\n      timestamp: new Date().toISOString(),\n      status: \'error\'\n    });\n    \n    res.status(500).json({\n      status: \'error\',\n      message: error.message,\n      timestamp: new Date().toISOString()\n    });\n  }\n});\n\n// Webhook endpoint\napp.post(\'/webhook/:service\', (req, res) => {\n  const service = req.params.service;\n  const payload = req.body;\n  \n  console.log(`Webhook received from ${service}`);\n  \n  // Emit webhook event\n  io.emit(\'webhook_received\', {\n    service,\n    payload,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Process webhook based on service\n  processWebhook(service, payload);\n  \n  res.json({\n    status: \'received\',\n    service,\n    timestamp: new Date().toISOString()\n  });\n});\n\n// Real-time data endpoint\napp.get(\'/realtime/data\', (req, res) => {\n  const data = {\n    system: \'HEX-CyberSphere\',\n    timestamp: new Date().toISOString(),\n    connections: connections.size,\n    events: {\n      total: global.eventCounter || 0,\n      last_hour: global.hourlyEvents || 0\n    }\n  };\n  \n  res.json(data);\n});\n\n// Socket.IO connection handling\nio.on(\'connection\', (socket) => {\n  console.log(`Client connected: ${socket.id}`);\n  connections.set(socket.id, socket);\n  \n  // Send welcome message\n  socket.emit(\'welcome\', {\n    message: \'Connected to HEX-CyberSphere Node.js Event System\',\n    timestamp: new Date().toISOString()\n  });\n  \n  // Handle disconnection\n  socket.on(\'disconnect\', () => {\n    console.log(`Client disconnected: ${socket.id}`);\n    connections.delete(socket.id);\n  });\n  \n  // Handle custom events\n  socket.on(\'custom_event\', (data) => {\n    console.log(\'Custom event received:\', data);\n    // Broadcast to all other clients\n    socket.broadcast.emit(\'custom_event\', data);\n  });\n});\n\n// Perform web automation using Puppeteer\nasync function performWebAutomation(url, actions = [], options = {}) {\n  let browser;\n  \n  try {\n    // Launch browser\n    browser = await puppeteer.launch({\n      headless: \'new\',\n      args: [\'--no-sandbox\', \'--disable-setuid-sandbox\']\n    });\n    \n    const page = await browser.newPage();\n    \n    // Set viewport\n    await page.setViewport({ \n      width: options.width || 1920, \n      height: options.height || 1080 \n    });\n    \n    // Navigate to URL\n    await page.goto(url, { \n      waitUntil: \'networkidle2\',\n      timeout: 30000\n    });\n    \n    // Execute actions\n    const results = [];\n    for (const action of actions) {\n      try {\n        let result;\n        \n        switch (action.type) {\n          case \'click\':\n            await page.click(action.selector);\n            result = `Clicked on ${action.selector}`;\n            break;\n            \n          case \'type\':\n            await page.type(action.selector, action.text);\n            result = `Typed "${action.text}" into ${action.selector}`;\n            break;\n            \n          case \'wait\':\n            await page.waitForSelector(action.selector, { timeout: action.timeout || 5000 });\n            result = `Waited for ${action.selector}`;\n            break;\n            \n          case \'screenshot\':\n            const screenshot = await page.screenshot();\n            result = `Screenshot taken (${screenshot.length} bytes)`;\n            break;\n            \n          case \'evaluate\':\n            result = await page.evaluate(action.script);\n            break;\n            \n          default:\n            result = `Unknown action type: ${action.type}`;\n        }\n        \n        results.push({\n          action: action.type,\n          result,\n          timestamp: new Date().toISOString()\n        });\n      } catch (actionError) {\n        results.push({\n          action: action.type,\n          error: actionError.message,\n          timestamp: new Date().toISOString()\n        });\n      }\n    }\n    \n    // Get page title and URL\n    const title = await page.title();\n    const finalUrl = page.url();\n    \n    return {\n      url: finalUrl,\n      title,\n      actions: results,\n      timestamp: new Date().toISOString()\n    };\n  } finally {\n    // Close browser\n    if (browser) {\n      await browser.close();\n    }\n  }\n}\n\n// Process webhook based on service\nfunction processWebhook(service, payload) {\n  switch (service) {\n    case \'github\':\n      console.log(\'Processing GitHub webhook\');\n      // Handle GitHub events (push, pull request, etc.)\n      break;\n      \n    case \'discord\':\n      console.log(\'Processing Discord webhook\');\n      // Handle Discord events\n      break;\n      \n    case \'slack\':\n      console.log(\'Processing Slack webhook\');\n      // Handle Slack events\n      break;\n      \n    default:\n      console.log(`Unknown webhook service: ${service}`);\n  }\n  \n  // Emit processed event\n  io.emit(\'webhook_processed\', {\n    service,\n    payload,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// Broadcast system status\nfunction broadcastStatus() {\n  const status = {\n    system: \'HEX-CyberSphere\',\n    timestamp: new Date().toISOString(),\n    connections: connections.size,\n    memory: process.memoryUsage(),\n    uptime: process.uptime()\n  };\n  \n  io.emit(\'system_status\', status);\n}\n\n// Send periodic status updates\nsetInterval(broadcastStatus, 5000); // Every 5 seconds\n\n// Start server\nconst PORT = process.env.PORT || 3000;\nserver.listen(PORT, () => {\n  console.log(\'╔════════════════════════════════════════════════╗\');\n  console.log(\'║              ⚡ H E X – C Y B E R S P H E R E ⚡              ║\');\n  console.log(\'╚════════════════════════════════════════════════╝\');\n  console.log(\'     Node.js Event System Started\');\n  console.log(`  Listening on port ${PORT}`);\n  console.log(\'  Real-time communication ready\');\n});\n\n// Graceful shutdown\nprocess.on(\'SIGTERM\', () => {\n  console.log(\'SIGTERM received, shutting down gracefully\');\n  server.close(() => {\n    console.log(\'Process terminated\');\n    process.exit(0);\n  });\n});\n\nprocess.on(\'SIGINT\', () => {\n  console.log(\'SIGINT received, shutting down gracefully\');\n  server.close(() => {\n    console.log(\'Process terminated\');\n    process.exit(0);\n  });\n});\n</create-file>\n</function_calls>'}