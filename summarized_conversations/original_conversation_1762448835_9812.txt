{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="HEX-CyberSphere/node_events/puppeteer_automation.js">\n/**\n * HEX-CyberSphere Puppeteer Automation Module\n * Specialized web automation using Puppeteer\n */\n\nconst puppeteer = require(\'puppeteer\');\nconst fs = require(\'fs\').promises;\n\nclass PuppeteerAutomation {\n  constructor() {\n    this.browser = null;\n    this.activePages = new Map();\n  }\n  \n  // Initialize browser instance\n  async init(options = {}) {\n    try {\n      this.browser = await puppeteer.launch({\n        headless: options.headless !== false, // Default to headless\n        args: [\n          \'--no-sandbox\',\n          \'--disable-setuid-sandbox\',\n          \'--disable-dev-shm-usage\',\n          \'--disable-accelerated-2d-canvas\',\n          \'--no-first-run\',\n          \'--no-zygote\',\n          \'--disable-gpu\'\n        ],\n        ...options\n      });\n      \n      console.log(\'Puppeteer browser initialized\');\n      return true;\n    } catch (error) {\n      console.error(\'Failed to initialize Puppeteer browser:\', error);\n      return false;\n    }\n  }\n  \n  // Navigate to URL\n  async navigate(url, options = {}) {\n    try {\n      if (!this.browser) {\n        throw new Error(\'Browser not initialized. Call init() first.\');\n      }\n      \n      const page = await this.browser.newPage();\n      const pageId = Date.now().toString();\n      \n      // Set viewport\n      await page.setViewport({\n        width: options.width || 1920,\n        height: options.height || 1080\n      });\n      \n      // Set user agent\n      await page.setUserAgent(options.userAgent || \n        \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\');\n      \n      // Navigate to URL\n      await page.goto(url, {\n        waitUntil: options.waitUntil || \'networkidle2\',\n        timeout: options.timeout || 30000\n      });\n      \n      // Store page reference\n      this.activePages.set(pageId, { page, url, createdAt: new Date() });\n      \n      return {\n        pageId,\n        url,\n        title: await page.title(),\n        status: \'success\'\n      };\n    } catch (error) {\n      console.error(\'Navigation failed:\', error);\n      return { status: \'error\', message: error.message };\n    }\n  }\n  \n  // Perform actions on a page\n  async performActions(pageId, actions) {\n    try {\n      const pageEntry = this.activePages.get(pageId);\n      if (!pageEntry) {\n        throw new Error(`Page with ID ${pageId} not found`);\n      }\n      \n      const { page } = pageEntry;\n      const results = [];\n      \n      for (const action of actions) {\n        try {\n          let result;\n          \n          switch (action.type) {\n            case \'click\':\n              await page.click(action.selector, action.options);\n              result = `Clicked on ${action.selector}`;\n              break;\n              \n            case \'type\':\n              await page.type(action.selector, action.text, action.options);\n              result = `Typed "${action.text}" into ${action.selector}`;\n              break;\n              \n            case \'waitForSelector\':\n              await page.waitForSelector(action.selector, action.options);\n              result = `Waited for ${action.selector}`;\n              break;\n              \n            case \'waitForTimeout\':\n              await page.waitForTimeout(action.timeout);\n              result = `Waited for ${action.timeout}ms`;\n              break;\n              \n            case \'screenshot\':\n              const screenshotOptions = {\n                encoding: \'base64\',\n                ...action.options\n              };\n              const screenshot = await page.screenshot(screenshotOptions);\n              result = { \n                type: \'screenshot\', \n                data: screenshot,\n                message: \'Screenshot taken\'\n              };\n              break;\n              \n            case \'extractText\':\n              const text = await page.evaluate((selector) => {\n                const element = document.querySelector(selector);\n                return element ? element.textContent.trim() : null;\n              }, action.selector);\n              result = { \n                type: \'extracted_text\', \n                selector: action.selector,\n                text \n              };\n              break;\n              \n            case \'extractAttribute\':\n              const attribute = await page.evaluate(({ selector, attr }) => {\n                const element = document.querySelector(selector);\n                return element ? element.getAttribute(attr) : null;\n              }, { selector: action.selector, attr: action.attribute });\n              result = { \n                type: \'extracted_attribute\', \n                selector: action.selector,\n                attribute: action.attribute,\n                value: attribute\n              };\n              break;\n              \n            case \'evaluate\':\n              const evaluation = await page.evaluate(action.script);\n              result = { \n                type: \'evaluation\', \n                result: evaluation\n              };\n              break;\n              \n            default:\n              result = `Unknown action type: ${action.type}`;\n          }\n          \n          results.push({\n            action: action.type,\n            result,\n            timestamp: new Date().toISOString()\n          });\n        } catch (actionError) {\n          results.push({\n            action: action.type,\n            error: actionError.message,\n            timestamp: new Date().toISOString()\n          });\n        }\n      }\n      \n      return {\n        pageId,\n        actions: results,\n        status: \'success\'\n      };\n    } catch (error) {\n      console.error(\'Action execution failed:\', error);\n      return { status: \'error\', message: error.message };\n    }\n  }\n  \n  // Close a specific page\n  async closePage(pageId) {\n    try {\n      const pageEntry = this.activePages.get(pageId);\n      if (!pageEntry) {\n        throw new Error(`Page with ID ${pageId} not found`);\n      }\n      \n      const { page } = pageEntry;\n      await page.close();\n      this.activePages.delete(pageId);\n      \n      return { status: \'success\', message: `Page ${pageId} closed` };\n    } catch (error) {\n      console.error(\'Failed to close page:\', error);\n      return { status: \'error\', message: error.message };\n    }\n  }\n  \n  // Get all active pages\n  getActivePages() {\n    return Array.from(this.activePages.entries()).map(([id, info]) => ({\n      id,\n      url: info.url,\n      createdAt: info.createdAt\n    }));\n  }\n  \n  // Close all pages and browser\n  async close() {\n    try {\n      // Close all pages\n      for (const [pageId] of this.activePages) {\n        await this.closePage(pageId);\n      }\n      \n      // Close browser\n      if (this.browser) {\n        await this.browser.close();\n        this.browser = null;\n      }\n      \n      console.log(\'Puppeteer automation closed\');\n      return { status: \'success\', message: \'All resources closed\' };\n    } catch (error) {\n      console.error(\'Failed to close Puppeteer automation:\', error);\n      return { status: \'error\', message: error.message };\n    }\n  }\n  \n  // Save page content to file\n  async savePageContent(pageId, filePath) {\n    try {\n      const pageEntry = this.activePages.get(pageId);\n      if (!pageEntry) {\n        throw new Error(`Page with ID ${pageId} not found`);\n      }\n      \n      const { page } = pageEntry;\n      const content = await page.content();\n      \n      await fs.writeFile(filePath, content, \'utf8\');\n      \n      return { \n        status: \'success\', \n        message: `Page content saved to ${filePath}`,\n        path: filePath\n      };\n    } catch (error) {\n      console.error(\'Failed to save page content:\', error);\n      return { status: \'error\', message: error.message };\n    }\n  }\n  \n  // Take full page screenshot\n  async takeFullScreenshot(pageId, filePath) {\n    try {\n      const pageEntry = this.activePages.get(pageId);\n      if (!pageEntry) {\n        throw new Error(`Page with ID ${pageId} not found`);\n      }\n      \n      const { page } = pageEntry;\n      await page.screenshot({ \n        path: filePath, \n        fullPage: true \n      });\n      \n      return { \n        status: \'success\', \n        message: `Full page screenshot saved to ${filePath}`,\n        path: filePath\n      };\n    } catch (error) {\n      console.error(\'Failed to take full page screenshot:\', error);\n      return { status: \'error\', message: error.message };\n    }\n  }\n}\n\n// Export the class\nmodule.exports = PuppeteerAutomation;\n\n// Example usage\nif (require.main === module) {\n  (async () => {\n    const automation = new PuppeteerAutomation();\n    \n    try {\n      // Initialize browser\n      await automation.init();\n      \n      // Navigate to a website\n      const navResult = await automation.navigate(\'https://example.com\');\n      console.log(\'Navigation result:\', navResult);\n      \n      if (navResult.status === \'success\') {\n        // Perform actions\n        const actions = [\n          { type: \'extractText\', selector: \'h1\' },\n          { type: \'screenshot\' }\n        ];\n        \n        const actionResult = await automation.performActions(navResult.pageId, actions);\n        console.log(\'Action result:\', actionResult);\n        \n        // Save page content\n        const saveResult = await automation.savePageContent(navResult.pageId, \'example_page.html\');\n        console.log(\'Save result:\', saveResult);\n        \n        // Close page\n        await automation.closePage(navResult.pageId);\n      }\n      \n      // Close browser\n      await automation.close();\n    } catch (error) {\n      console.error(\'Example execution failed:\', error);\n    }\n  })();\n}\n</create-file>\n</function_calls>'}