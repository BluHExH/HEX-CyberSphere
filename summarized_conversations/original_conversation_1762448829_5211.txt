{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="HEX-CyberSphere/core_engine/notifier.py">\n"""\nHEX-CyberSphere Notification Manager\nHandles sending notifications via various channels\n"""\n\nimport json\nimport logging\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nimport requests\nfrom typing import Dict, Any\n\nclass NotificationManager:\n    def __init__(self, config_path="../config/config.json"):\n        self.logger = logging.getLogger(__name__)\n        self.config = self._load_config(config_path)\n        self.logger.info("Notification Manager initialized")\n    \n    def _load_config(self, config_path: str) -> Dict[Any, Any]:\n        """Load configuration from JSON file"""\n        try:\n            with open(config_path, \'r\') as f:\n                return json.load(f)\n        except Exception as e:\n            self.logger.error(f"Failed to load config: {e}")\n            return {}\n    \n    def send_discord_notification(self, message: str, webhook_url: str = None) -> bool:\n        """Send notification via Discord webhook"""\n        try:\n            if not webhook_url:\n                webhook_url = self.config.get(\'notifications\', {}).get(\'discord\', {}).get(\'webhook_url\')\n            \n            if not webhook_url:\n                self.logger.warning("Discord webhook URL not configured")\n                return False\n            \n            payload = {\n                "content": message,\n                "username": "HEX-CyberSphere"\n            }\n            \n            response = requests.post(webhook_url, json=payload)\n            return response.status_code == 204\n        except Exception as e:\n            self.logger.error(f"Failed to send Discord notification: {e}")\n            return False\n    \n    def send_telegram_notification(self, message: str, bot_token: str = None, chat_id: str = None) -> bool:\n        """Send notification via Telegram bot"""\n        try:\n            if not bot_token:\n                bot_token = self.config.get(\'notifications\', {}).get(\'telegram\', {}).get(\'bot_token\')\n            \n            if not chat_id:\n                chat_id = self.config.get(\'notifications\', {}).get(\'telegram\', {}).get(\'chat_id\')\n            \n            if not bot_token or not chat_id:\n                self.logger.warning("Telegram bot token or chat ID not configured")\n                return False\n            \n            url = f"https://api.telegram.org/bot{bot_token}/sendMessage"\n            payload = {\n                "chat_id": chat_id,\n                "text": message\n            }\n            \n            response = requests.post(url, json=payload)\n            return response.status_code == 200\n        except Exception as e:\n            self.logger.error(f"Failed to send Telegram notification: {e}")\n            return False\n    \n    def send_email_notification(self, subject: str, message: str, \n                               recipient: str = None, smtp_config: Dict[Any, Any] = None) -> bool:\n        """Send notification via email"""\n        try:\n            if not smtp_config:\n                smtp_config = self.config.get(\'notifications\', {}).get(\'email\', {})\n            \n            if not smtp_config.get(\'enabled\'):\n                self.logger.warning("Email notifications not enabled")\n                return False\n            \n            # Create message\n            msg = MIMEMultipart()\n            msg[\'From\'] = smtp_config.get(\'username\')\n            msg[\'To\'] = recipient or smtp_config.get(\'username\')\n            msg[\'Subject\'] = subject\n            \n            msg.attach(MIMEText(message, \'plain\'))\n            \n            # Connect to server and send email\n            server = smtplib.SMTP(smtp_config.get(\'smtp_server\'), smtp_config.get(\'port\'))\n            server.starttls()\n            server.login(smtp_config.get(\'username\'), smtp_config.get(\'password\'))\n            \n            text = msg.as_string()\n            server.sendmail(smtp_config.get(\'username\'), \n                           recipient or smtp_config.get(\'username\'), text)\n            server.quit()\n            \n            return True\n        except Exception as e:\n            self.logger.error(f"Failed to send email notification: {e}")\n            return False\n    \n    def send_notification(self, message: str, channels: list = None) -> Dict[str, bool]:\n        """Send notification via multiple channels"""\n        if not channels:\n            # Use all enabled channels\n            channels = []\n            notifications_config = self.config.get(\'notifications\', {})\n            \n            if notifications_config.get(\'discord\', {}).get(\'enabled\'):\n                channels.append(\'discord\')\n            \n            if notifications_config.get(\'telegram\', {}).get(\'enabled\'):\n                channels.append(\'telegram\')\n            \n            if notifications_config.get(\'email\', {}).get(\'enabled\'):\n                channels.append(\'email\')\n        \n        results = {}\n        \n        for channel in channels:\n            if channel == \'discord\':\n                results[channel] = self.send_discord_notification(message)\n            elif channel == \'telegram\':\n                results[channel] = self.send_telegram_notification(message)\n            elif channel == \'email\':\n                results[channel] = self.send_email_notification("HEX-CyberSphere Notification", message)\n            else:\n                self.logger.warning(f"Unknown notification channel: {channel}")\n                results[channel] = False\n        \n        return results\n    \n    def generate_report(self, report_data: Dict[Any, Any] = None) -> str:\n        """Generate a system status report"""\n        try:\n            if not report_data:\n                # Generate a default report\n                report_data = {\n                    "system": "HEX-CyberSphere",\n                    "status": "Operational",\n                    "timestamp": __import__(\'datetime\').datetime.now().isoformat(),\n                    "summary": "System is running normally"\n                }\n            \n            # Format report\n            report_lines = [\n                "=== HEX-CyberSphere System Report ===",\n                f"Generated: {report_data.get(\'timestamp\', \'N/A\')}",\n                f"System: {report_data.get(\'system\', \'N/A\')}",\n                f"Status: {report_data.get(\'status\', \'N/A\')}",\n                "",\n                f"Summary: {report_data.get(\'summary\', \'N/A\')}"\n            ]\n            \n            # Add additional sections if available\n            if \'tasks\' in report_data:\n                report_lines.append("\\n=== Task Summary ===")\n                for task in report_data[\'tasks\']:\n                    report_lines.append(f"- {task}")\n            \n            if \'alerts\' in report_data:\n                report_lines.append("\\n=== Alerts ===")\n                for alert in report_data[\'alerts\']:\n                    report_lines.append(f"- {alert}")\n            \n            report = "\\n".join(report_lines)\n            return report\n        except Exception as e:\n            self.logger.error(f"Failed to generate report: {e}")\n            return "Failed to generate report"\n\n# Example usage\nif __name__ == "__main__":\n    notifier = NotificationManager()\n    \n    # Test notification sending\n    print("Sending test notification...")\n    results = notifier.send_notification("HEX-CyberSphere system test notification")\n    print(json.dumps(results, indent=2))\n    \n    # Test report generation\n    print("\\nGenerating system report...")\n    report_data = {\n        "system": "HEX-CyberSphere",\n        "status": "Operational",\n        "timestamp": "2024-01-01T12:00:00Z",\n        "summary": "All systems operational",\n        "tasks": ["Data processing completed", "Security scan finished"],\n        "alerts": ["Minor performance degradation detected"]\n    }\n    \n    report = notifier.generate_report(report_data)\n    print(report)\n</create-file>\n</function_calls>'}