{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="HEX-CyberSphere/cpp_engine/hash_core.cpp">\n/*\nHEX-CyberSphere C++ Hashing Module\nHigh-speed hashing functions for data integrity\n*/\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <openssl/md5.h>\n#include <openssl/sha.h>\n#include <iomanip>\n#include <sstream>\n#include <chrono>\n\nclass HashCore {\npublic:\n    // MD5 hashing\n    std::string hashMD5(const std::string& input) {\n        unsigned char digest[MD5_DIGEST_LENGTH];\n        MD5(reinterpret_cast<const unsigned char*>(input.c_str()), input.length(), digest);\n\n        std::stringstream ss;\n        for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n            ss << std::hex << std::setw(2) << std::setfill(\'0\') << static_cast<int>(digest[i]);\n        }\n        return ss.str();\n    }\n\n    // SHA-1 hashing\n    std::string hashSHA1(const std::string& input) {\n        unsigned char digest[SHA_DIGEST_LENGTH];\n        SHA1(reinterpret_cast<const unsigned char*>(input.c_str()), input.length(), digest);\n\n        std::stringstream ss;\n        for (int i = 0; i < SHA_DIGEST_LENGTH; i++) {\n            ss << std::hex << std::setw(2) << std::setfill(\'0\') << static_cast<int>(digest[i]);\n        }\n        return ss.str();\n    }\n\n    // SHA-256 hashing\n    std::string hashSHA256(const std::string& input) {\n        unsigned char digest[SHA256_DIGEST_LENGTH];\n        SHA256_CTX sha256;\n        SHA256_Init(&sha256);\n        SHA256_Update(&sha256, input.c_str(), input.length());\n        SHA256_Final(digest, &sha256);\n\n        std::stringstream ss;\n        for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {\n            ss << std::hex << std::setw(2) << std::setfill(\'0\') << static_cast<int>(digest[i]);\n        }\n        return ss.str();\n    }\n\n    // SHA-512 hashing\n    std::string hashSHA512(const std::string& input) {\n        unsigned char digest[SHA512_DIGEST_LENGTH];\n        SHA512_CTX sha512;\n        SHA512_Init(&sha512);\n        SHA512_Update(&sha512, input.c_str(), input.length());\n        SHA512_Final(digest, &sha512);\n\n        std::stringstream ss;\n        for (int i = 0; i < SHA512_DIGEST_LENGTH; i++) {\n            ss << std::hex << std::setw(2) << std::setfill(\'0\') << static_cast<int>(digest[i]);\n        }\n        return ss.str();\n    }\n\n    // Benchmark hashing performance\n    double benchmarkHash(const std::string& input, const std::string& hashType, int iterations = 1000) {\n        auto start = std::chrono::high_resolution_clock::now();\n\n        for (int i = 0; i < iterations; i++) {\n            if (hashType == "md5") {\n                hashMD5(input);\n            } else if (hashType == "sha1") {\n                hashSHA1(input);\n            } else if (hashType == "sha256") {\n                hashSHA256(input);\n            } else if (hashType == "sha512") {\n                hashSHA512(input);\n            }\n        }\n\n        auto end = std::chrono::high_resolution_clock::now();\n        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);\n        return duration.count() / static_cast<double>(iterations);\n    }\n\n    // Verify data integrity\n    bool verifyIntegrity(const std::string& data, const std::string& expectedHash, const std::string& hashType) {\n        std::string actualHash;\n        \n        if (hashType == "md5") {\n            actualHash = hashMD5(data);\n        } else if (hashType == "sha1") {\n            actualHash = hashSHA1(data);\n        } else if (hashType == "sha256") {\n            actualHash = hashSHA256(data);\n        } else if (hashType == "sha512") {\n            actualHash = hashSHA512(data);\n        } else {\n            return false;\n        }\n\n        return actualHash == expectedHash;\n    }\n};\n\n// Main function for testing\nint main() {\n    std::cout << "╔════════════════════════════════════════════════╗" << std::endl;\n    std::cout << "║              ⚡ H E X – C Y B E R S P H E R E ⚡              ║" << std::endl;\n    std::cout << "╚════════════════════════════════════════════════╝" << std::endl;\n    std::cout << "     C++ Hashing Engine" << std::endl;\n    std::cout << "  High-speed data integrity verification" << std::endl;\n    std::cout << std::endl;\n\n    HashCore hasher;\n\n    // Test data\n    std::string testData = "HEX-CyberSphere data integrity test";\n    std::cout << "Test data: " << testData << std::endl;\n    std::cout << std::endl;\n\n    // Test different hash algorithms\n    std::string md5Hash = hasher.hashMD5(testData);\n    std::cout << "MD5: " << md5Hash << std::endl;\n\n    std::string sha1Hash = hasher.hashSHA1(testData);\n    std::cout << "SHA-1: " << sha1Hash << std::endl;\n\n    std::string sha256Hash = hasher.hashSHA256(testData);\n    std::cout << "SHA-256: " << sha256Hash << std::endl;\n\n    std::string sha512Hash = hasher.hashSHA512(testData);\n    std::cout << "SHA-512: " << sha512Hash << std::endl;\n\n    std::cout << std::endl;\n\n    // Test data integrity verification\n    bool md5Valid = hasher.verifyIntegrity(testData, md5Hash, "md5");\n    bool sha256Valid = hasher.verifyIntegrity(testData, sha256Hash, "sha256");\n\n    std::cout << "MD5 integrity check: " << (md5Valid ? "PASSED" : "FAILED") << std::endl;\n    std::cout << "SHA-256 integrity check: " << (sha256Valid ? "PASSED" : "FAILED") << std::endl;\n\n    std::cout << std::endl;\n\n    // Benchmark performance\n    std::cout << "Performance benchmarks (average microseconds per hash):" << std::endl;\n    std::cout << "MD5: " << hasher.benchmarkHash(testData, "md5") << " μs" << std::endl;\n    std::cout << "SHA-1: " << hasher.benchmarkHash(testData, "sha1") << " μs" << std::endl;\n    std::cout << "SHA-256: " << hasher.benchmarkHash(testData, "sha256") << " μs" << std::endl;\n    std::cout << "SHA-512: " << hasher.benchmarkHash(testData, "sha512") << " μs" << std::endl;\n\n    return 0;\n}\n</create-file>\n</function_calls>'}