{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="HEX-CyberSphere/core_engine/security_scanner.py">\n"""\nHEX-CyberSphere Security Scanner\nHandles security scanning and vulnerability detection\n"""\n\nimport socket\nimport subprocess\nimport json\nimport logging\nfrom typing import Dict, Any, List\nimport requests\n\nclass SecurityScanner:\n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self.logger.info("Security Scanner initialized")\n    \n    def scan_ports(self, target: str, port_range: str = "1-1000") -> Dict[Any, Any]:\n        """Scan open ports on a target"""\n        self.logger.info(f"Scanning ports on {target}")\n        \n        try:\n            open_ports = []\n            start_port, end_port = map(int, port_range.split(\'-\'))\n            \n            for port in range(start_port, end_port + 1):\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                sock.settimeout(0.1)  # 100ms timeout\n                \n                result = sock.connect_ex((target, port))\n                if result == 0:\n                    # Port is open\n                    try:\n                        service = socket.getservbyport(port)\n                    except:\n                        service = "unknown"\n                    \n                    open_ports.append({\n                        "port": port,\n                        "service": service,\n                        "status": "open"\n                    })\n                \n                sock.close()\n            \n            return {\n                "target": target,\n                "scan_type": "port_scan",\n                "open_ports": open_ports,\n                "total_scanned": end_port - start_port + 1\n            }\n        except Exception as e:\n            error_msg = f"Port scanning failed: {str(e)}"\n            self.logger.error(error_msg)\n            return {"error": error_msg}\n    \n    def scan_vulnerabilities(self, target: str) -> Dict[Any, Any]:\n        """Scan for common vulnerabilities"""\n        self.logger.info(f"Scanning vulnerabilities on {target}")\n        \n        try:\n            vulnerabilities = []\n            \n            # Check for common vulnerabilities\n            # 1. Check if common ports are open with weak services\n            common_ports = [\n                (21, "FTP"), (22, "SSH"), (23, "Telnet"), \n                (80, "HTTP"), (443, "HTTPS"), (3389, "RDP")\n            ]\n            \n            for port, service_name in common_ports:\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                sock.settimeout(0.5)\n                \n                result = sock.connect_ex((target, port))\n                if result == 0:\n                    vulnerabilities.append({\n                        "type": "open_port",\n                        "port": port,\n                        "service": service_name,\n                        "risk": "info" if port in [80, 443] else "medium",\n                        "description": f"{service_name} service running on port {port}"\n                    })\n                \n                sock.close()\n            \n            # 2. Check for HTTP headers security issues\n            try:\n                response = requests.get(f"http://{target}", timeout=5)\n                headers = response.headers\n                \n                # Check for missing security headers\n                security_headers = [\n                    "X-Content-Type-Options",\n                    "X-Frame-Options", \n                    "X-XSS-Protection",\n                    "Strict-Transport-Security"\n                ]\n                \n                missing_headers = []\n                for header in security_headers:\n                    if header not in headers:\n                        missing_headers.append(header)\n                \n                if missing_headers:\n                    vulnerabilities.append({\n                        "type": "missing_security_headers",\n                        "risk": "medium",\n                        "description": f"Missing security headers: {\', \'.join(missing_headers)}",\n                        "headers": missing_headers\n                    })\n            except:\n                pass  # Ignore if HTTP service is not available\n            \n            return {\n                "target": target,\n                "scan_type": "vulnerability_scan",\n                "vulnerabilities": vulnerabilities,\n                "total_found": len(vulnerabilities)\n            }\n        except Exception as e:\n            error_msg = f"Vulnerability scanning failed: {str(e)}"\n            self.logger.error(error_msg)\n            return {"error": error_msg}\n    \n    def full_scan(self, target: str) -> Dict[Any, Any]:\n        """Perform a full security scan"""\n        self.logger.info(f"Performing full security scan on {target}")\n        \n        try:\n            # Run port scan\n            port_results = self.scan_ports(target)\n            \n            # Run vulnerability scan\n            vuln_results = self.scan_vulnerabilities(target)\n            \n            # Combine results\n            combined_results = {\n                "target": target,\n                "scan_type": "full_scan",\n                "timestamp": __import__(\'datetime\').datetime.now().isoformat(),\n                "port_scan": port_results,\n                "vulnerability_scan": vuln_results,\n                "summary": {\n                    "total_open_ports": len(port_results.get("open_ports", [])),\n                    "total_vulnerabilities": len(vuln_results.get("vulnerabilities", []))\n                }\n            }\n            \n            return combined_results\n        except Exception as e:\n            error_msg = f"Full security scan failed: {str(e)}"\n            self.logger.error(error_msg)\n            return {"error": error_msg}\n    \n    def check_api_security(self, api_url: str) -> Dict[Any, Any]:\n        """Check security of an API endpoint"""\n        self.logger.info(f"Checking API security for {api_url}")\n        \n        try:\n            vulnerabilities = []\n            \n            # Check if API requires authentication\n            try:\n                response = requests.get(api_url, timeout=5)\n                \n                # If we can access without auth, it\'s a potential issue\n                if response.status_code == 200:\n                    vulnerabilities.append({\n                        "type": "unauthenticated_access",\n                        "risk": "high",\n                        "description": "API endpoint accessible without authentication"\n                    })\n            except:\n                pass  # Ignore connection errors\n            \n            # Check for common API security issues would go here\n            # This is a simplified version\n            \n            return {\n                "api_url": api_url,\n                "vulnerabilities": vulnerabilities,\n                "total_found": len(vulnerabilities)\n            }\n        except Exception as e:\n            error_msg = f"API security check failed: {str(e)}"\n            self.logger.error(error_msg)\n            return {"error": error_msg}\n\n# Example usage\nif __name__ == "__main__":\n    scanner = SecurityScanner()\n    \n    # Test port scanning\n    print("Scanning ports on localhost...")\n    port_results = scanner.scan_ports("localhost", "80-100")\n    print(json.dumps(port_results, indent=2))\n    \n    # Test vulnerability scanning\n    print("\\nScanning vulnerabilities on localhost...")\n    vuln_results = scanner.scan_vulnerabilities("localhost")\n    print(json.dumps(vuln_results, indent=2))\n</create-file>\n</function_calls>'}